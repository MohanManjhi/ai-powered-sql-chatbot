import os
import pandas as pd
import google.generativeai as genai
from dotenv import load_dotenv
from flask import Flask, jsonify, request
from flask_cors import CORS
from sqlalchemy import create_engine, text
import sqlparse

# --- INITIALIZATION ---
load_dotenv() # Load environment variables from .env file

# Configure the Gemini API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

# Create a Flask app
app = Flask(__name__)
CORS(app) # Enable Cross-Origin Resource Sharing

# --- DATABASE CONNECTION ---
# Use SQLite for local development as planned
DB_URI = "sqlite:///database.db" 
engine = create_engine(DB_URI)

# --- HELPER FUNCTIONS ---

def get_db_schema():
    """
    Dynamically retrieves the database schema (table names and their columns).
    This implements Step 2 from the architecture diagram.
    """
    with engine.connect() as connection:
        # For SQLite, we query the sqlite_master table
        query = "SELECT name FROM sqlite_master WHERE type='table';"
        tables = pd.read_sql_query(text(query), connection)['name'].tolist()
        
        schema_info = ""
        for table_name in tables:
            # Skip internal sqlite tables
            if table_name.startswith('sqlite_'):
                continue
            schema_info += f"Table '{table_name}':\n"
            # Get column info for each table
            columns_query = f"PRAGMA table_info({table_name});"
            columns_df = pd.read_sql_query(text(columns_query), connection)
            schema_info += columns_df[['name', 'type']].to_string(index=False) + "\n\n"
            
    return schema_info.strip()

def validate_sql_query(sql_query):
    """
    Validates the SQL query generated by the LLM.
    This is the core security safeguard (Step 5 from the architecture).
    """
    # 1. Strict SELECT Enforcement & Blacklisting dangerous keywords
    disallowed_keywords = [
        "INSERT", "UPDATE", "DELETE", "DROP", "CREATE", "ALTER", "TRUNCATE", 
        "GRANT", "REVOKE", "COMMIT", "ROLLBACK", "MERGE"
    ]
    
    # Use sqlparse to break down the query
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return False, "Invalid SQL: Could not be parsed."

    # 2. Check for multiple statements to prevent SQL injection
    if len(parsed) > 1:
        return False, "Security Error: Multiple SQL statements are not allowed."

    statement = parsed[0]
    
    # 3. Ensure it's a SELECT statement
    if statement.get_type() != 'SELECT':
        return False, "Security Error: Only SELECT queries are allowed."

    # 4. Check for any disallowed keywords in the entire query string
    for keyword in disallowed_keywords:
        if keyword.lower() in str(statement).lower():
            return False, f"Security Error: Use of disallowed keyword '{keyword}'."
            
    return True, "Query is valid."


def get_llm_response(db_schema, user_query):
    """
    Generates a SQL query from a natural language question using the LLM.
    This covers Steps 3 & 4 from the architecture.
    """
    # Using a newer, capable model
    model = genai.GenerativeModel('gemini-1.5-flash')

    # Crafting the prompt with clear instructions for the LLM
    prompt = f"""
    You are an expert SQL assistant. Your task is to convert a natural language question into a valid SQL SELECT query for a given database schema.

    **Database Schema:**
    ```
    {db_schema}
    ```

    **Instructions:**
    1.  Only generate a single, valid SQL SELECT query.
    2.  Do NOT generate any other SQL statements like INSERT, UPDATE, DELETE, DROP, etc.
    3.  If the question cannot be answered with a SELECT query based on the schema, or if it's a request for a malicious operation, respond with the exact text: "UNSUPPORTED".
    4.  Do not add any explanations, introductory text, or markdown formatting around the SQL query. Just provide the raw SQL.

    **User's Question:** "{user_query}"

    **Generated SQL Query:**
    """
    
    response = model.generate_content(prompt)
    
    try:
        sql_query = response.text.strip()
        # Clean up potential markdown formatting from the LLM response
        if sql_query.startswith("```sql"):
            sql_query = sql_query[6:].strip()
        if sql_query.endswith("```"):
            sql_query = sql_query[:-3].strip()
        return sql_query
    except Exception as e:
        print(f"Error parsing LLM response: {e}")
        return "UNSUPPORTED"


# --- API ENDPOINT ---
@app.route('/api/query', methods=['POST'])
def handle_query():
    """
    The main API endpoint that orchestrates the entire process.
    """
    data = request.get_json()
    if not data or 'query' not in data:
        return jsonify({"error": "Invalid request. 'query' field is missing."}), 400

    user_query = data['query']
    
    try:
        # 1. Get database schema
        db_schema = get_db_schema()

        # 2. Get SQL from LLM
        generated_sql = get_llm_response(db_schema, user_query)

        if not generated_sql or generated_sql == "UNSUPPORTED":
            return jsonify({
                "error": "I cannot answer that question. It may be outside the scope of the available data or is not a valid request."
            }), 400

        # 3. **CRITICAL:** Validate the generated SQL
        is_valid, message = validate_sql_query(generated_sql)
        if not is_valid:
            print(f"SECURITY ALERT: Invalid query blocked. Reason: {message}. Query: {generated_sql}")
            return jsonify({"error": f"Security validation failed: {message}"}), 400

        # 4. Execute the validated SQL
        with engine.connect() as connection:
            result_df = pd.read_sql_query(text(generated_sql), connection)
            result_data = result_df.to_dict(orient='records')
            
            # For now, we'll return a simple success message and the data
            # Natural language summary and chart config will be added later
            return jsonify({
                "summary": f"Query executed successfully. Found {len(result_data)} records.",
                "data": result_data,
                "columns": list(result_df.columns),
                "chart_config": {} # Placeholder for future implementation
            })

    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return jsonify({"error": "An internal error occurred while processing your request."}), 500


# --- MAIN EXECUTION ---
if __name__ == '__main__':
    app.run(debug=True, port=5001) # Using port 5001 to avoid conflicts